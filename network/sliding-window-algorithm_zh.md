# [滑动窗口算法](https://www.baeldung.com/cs/sliding-window-algorithm)

1. 概述

    在处理需要检查给定数组内某些范围的答案的问题时，滑动窗口算法是一种非常强大的技术。

    在本教程中，我们将讲解滑动窗口技术的两种变体--固定窗口大小和灵活窗口大小。此外，我们还将提供这两种变体的示例，以便更好地理解。

2. 理论思想

    滑动窗口技术的主要思想是将两个嵌套循环转换为一个循环。通常，该技术可以帮助我们将时间复杂度从 $O(n^2)$ 降低到 $O(n)$。

    使用滑动窗口技术的条件是，问题要求找到一个函数的最大值（或最小值），该函数会重复计算数组中一组范围的答案。也就是说，如果这些范围可以根据其起点排序，并且其终点也可以排序，那么我们就可以使用滑动窗口技术。

    换句话说，以下条件必须成立：

    如果 $L_i \geq L_j$，那么 $R_i \geq R_j$，其中 $L_i$ 和 $L_j$ 是某些范围的左侧，而 $R_i$ 和 $R_j$ 是相同范围的左端。

    这些指针分别表示当前范围的左端和右端。在每一步中，我们要么移动 L、R，要么同时移动它们到下一个范围。

    为此，我们必须能够在向前移动 R 时向当前范围添加元素。同时，在向前移动 L 时，我们必须能够从当前范围中删除元素。每次到达一个范围时，我们都会根据当前范围内的元素计算其答案。

    如果范围的长度是固定的，我们称之为固定大小滑动窗口技术。但是，如果范围的长度可以改变，我们就称之为灵活窗口大小技术。我们将提供这两种方案的示例。

3. 固定大小的滑动窗口

    让我们通过一个示例来更好地理解这一概念。

    1. 问题

        问题要求我们找出数组内 k 个连续元素的最大和。

        换句话说，首先，我们需要计算数组内所有长度为 k 的范围之和。然后，我们必须返回所有计算结果中的最大和。

    2. 简单方法

        让我们看看解决这个问题的最简单方法：

        ```java
        algorithm maximumSumOverRangesNaive(A, n, k):
            // INPUT
            //   A = array to calculate the answer for
            //   n = length of the array
            //   k = size of the ranges
            // OUTPUT
            //   Returns the maximum sum among all ranges of length k

            answer <- 0
            for L <- 1 to n - k + 1:
                sum <- 0
                for i <- L to L + k - 1:
                    sum <- sum + A[i]
                answer <- maximum(answer, sum)

            return answer
        ```

        首先，我们遍历范围的所有可能开头。对于每个范围，我们遍历从 L 到 L + k - 1 的元素，并计算它们的总和。每一步之后，我们都会更新迄今为止的最佳答案。最后，答案变成旧答案和当前计算出的总和之间的最大值。

        最后，我们会返回在所有范围中找到的最佳答案。

        在最坏情况下，时间复杂度为 $O(n^2)$，其中 n 是数组的长度。

    3. 滑动窗口算法

        让我们尝试改进我们的天真方法，以获得更好的复杂度。

        首先，让我们找出每两个连续范围之间的关系。第一个范围显然是 $[1, k]$。但是，第二个范围将是 $[2，k+1]$。

        我们要执行两个操作才能从第一个范围移动到第二个范围： 第一个操作是将索引为 k+1 的元素添加到答案中。第二个操作是从答案中删除索引为 1 的元素。

        每次，在计算出相应范围的答案后，我们只需将计算出的总答案最大化即可。

        让我们来看看上述问题的解决方案：

        ```java
        algorithm maximumSumOverRangesSlidingWindow(A, n, k):
            // INPUT
            //   A = array to calculate the answer for
            //   n = length of the array
            //   k = size of the ranges
            // OUTPUT
            //   Returns the maximum sum among all ranges of length k

            sum <- 0
            for i <- 1 to k:
                sum <- sum + A[i]
            answer <- sum

            for i <- k + 1 to n:
                sum <- sum + A[i] - A[i - k]
                answer <- maximum(answer, sum)

            return answer
        ```

        首先，我们计算第一个范围 $[1, k]$ 的总和。其次，我们将其总和存储为迄今为止的答案。

        然后，我们遍历范围 $[k+1, n]$ 内的范围的可能终点。在每一步中，我们都会更新当前范围的和。因此，我们会添加索引 $i$ 处元素的值，并删除索引 $i-k$ 处元素的值。

        每次，我们都会更新迄今为止找到的最佳答案，使其成为原始答案与新计算出的总和之间的最大值。最后，我们会返回在所有测试范围中找到的最佳答案。

        所述方法的时间复杂度为 $O(n)$，其中 $n$ 是数组的长度。

4. 灵活大小的滑动窗口

    我们将灵活大小的滑动窗口技术称为两点技术。为了更好地解释这种技术，我们也将举例说明。

    1. 问题

        假设有 n 本书排成一行。我们知道阅读每本书所需的分钟数。但是，我们只有 k 分钟的空闲时间来阅读。

        此外，我们还应该阅读该行中一些连续的书籍。换句话说，我们可以从这一排书中选择一个范围并阅读它们。当然，条件是阅读这些书所需的时间总和不能超过 k。

        因此，问题要求我们找出最多能读多少本书。也就是说，我们需要从数组中找出一个范围，其总和最多为 k，使得这个范围的长度尽可能最大。

    2. Naive方法

        来看看解决这个问题的简单方法：

        ```java
        algorithm maximumLengthRangeNaive(A, n, k):
            // INPUT
            //   A = array of time needed to read each book
            //   n = length of the array
            //   k = maximum number of minutes to read
            // OUTPUT
            //   Returns the maximum length of a range whose sum is at most k

            answer <- 0
            for L <- 1 to n:
                sum <- 0
                i <- L
                length <- 0
                while i <= n and sum + A[i] <= k:
                    sum <- sum + A[i]
                    length <- length + 1
                    i <- i + 1
                answer <- maximum(answer, length)

            return answer
        ```

        首先，我们将迄今为止的最佳答案初始化为 0。接下来，我们遍历范围内所有可能的开头。对于每个起始点，只要能读到更多的书，我们就向前遍历。一旦我们无法再阅读更多书籍，我们就会更新迄今为止的最佳答案，将其设为旧答案与我们找到的范围长度之间的最大值。

        最后，我们会返回找到的最佳答案。

        这种方法的复杂度为 $O(n^2)$，其中 n 是图书数组的长度。

    3. 滑动窗口算法

        我们将尝试改进天真算法，以获得线性复杂度。

        首先，假设我们成功找到了从数组开头开始的范围的答案。下一个范围从数组内的第二个索引开始。然而，第二个范围的终点肯定在第一个范围的终点之后。

        原因是第二个范围没有使用第一个元素。因此，第二个范围可以进一步延长其结束时间，因为它现在有更多的空闲时间可以使用。

        因此，当从一个范围移动到另一个范围时，我们首先要删除当前答案中的旧开头。同时，我们尽量延长当前范围的终点。

        因此，到最后，我们会遍历所有可能的范围，并存储我们找到的最佳答案。

        下面的算法与所解释的想法相对应：

        ```java
        algorithm maximumLengthRangeSlidingWindow(A, n, k):
            // INPUT
            //   A = array of time needed to read each book
            //   n = length of the array
            //   k = maximum number of minutes to be used
            // OUTPUT
            //   Returns the maximum length of a range whose sum is at most k

            answer <- 0
            sum <- 0
            R <- 1
            for L <- 1 to n:
                if L > 1:
                    sum <- sum - A[L - 1]
                while R <= n and sum + A[R] <= k:
                    sum <- sum + A[R]
                    R <- R + 1
                answer <- maximum(answer, R - L)

            return answer
        ```

        与传统方法一样，我们遍历范围内所有可能的起始数。对于每个起点，我们首先从当前总和中减去索引 L-1 的值。

        之后，我们将尽可能地移动 R。因此，只要总和仍然最多为 k，我们就会继续移动 R。因为当前范围的长度是 R-L，所以我们用这个值最大化最佳答案。

        虽然该算法看起来复杂度为 $O(n^2)$，但让我们仔细研究一下该算法。变量 R 始终保持其值。因此，它只会向前移动，直到达到 n 值。因此，我们执行 while 循环的总次数最多为 n 次。

        因此，所述方法的复杂度为 O(n)，其中 n 是数组的长度。

5. 差异

    主要区别在于，在某些问题中，我们需要在所有相同大小的范围中检查某个属性。另一方面，在其他一些问题中，我们需要在满足特定条件的所有范围中检查某个属性。在这种情况下，这个条件可能会使范围的长度各不相同。

    如果这些范围的大小是已知的（比如我们的连续元素问题），我们当然会采用固定大小的滑动窗口技术。但是，如果范围的大小不同（比如我们的书长问题），我们肯定会使用灵活大小的滑动窗口技术。

    此外，在使用滑动窗口技术时，请始终牢记我们在开头提到的以下条件：我们必须保证，向前移动 L 指针一定会使 R 指针保持原位或也向前移动。

6. 总结

    在本教程中，我们解释了滑动窗口方法。我们提供了该技术的理论思想。此外，我们还介绍了固定大小和灵活大小滑动窗口技术的两个示例。最后，我们解释了何时使用每种技术。
