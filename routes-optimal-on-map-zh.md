# 在地图上计算路线的算法

1. 简介

    在本教程中，我们将详细介绍在日常生活中寻找路径时，路由算法是如何在引擎盖下工作的。在讨论算法的细节之前，让我们先看看我们如何在地图上计算路径的基本步骤。

    首先，我们需要定义一个起点和终点。之后，我们应该看一下地图，确定起点和终点之间的可用路线。我们可能有公路、高速公路、隧道和桥梁等选择。

    接下来要做的是评估这些选项，并考虑交通、潜在路障或障碍等因素。在我们评估了可用的选项后，我们选择最适合我们需求的路线。

    所以，这就是我们寻找路径的一般方法。在计算中，地图被表示为图，有几种算法用于寻找[图](https://www.baeldung.com/cs/graphs)中节点之间的最短路径。

    例如，我们在日常生活中用来找路的地图应用通常使用基于Dijkstra算法的算法。它们通常结合不同的算法和技术来计算两个或多个地点之间的最佳路线。然而，主要的算法通常是在Dijkstra算法的基础上构建的。这就是为什么在这篇文章中，我们将详细分析Dijkstra和A*星算法。

2. 迪克斯特拉算法

    这种算法是以其发明者、计算机科学家Edsger Dijkstra的名字命名的。1959年，他在其论文 "[A note on two problems in connexion with graphs](https://link.springer.com/article/10.1007/bf01386390)" 中定义了该算法。Dijkstra开发了这个算法，作为道路网络中最短路径的解决方案。特别是针对鹿特丹和格罗宁根两个城市之间的路线。他还提到，他在发明这个算法时甚至没有使用铅笔和纸张。

    这个解释实际上也说明了这个算法的简单性和它的影响力。它在计算机科学领域广泛流行，并被广泛用于各种应用中。例如，从网络路由，和资源分配到数据压缩。

    1. 伪代码

        让我们从下面的伪代码中看看该算法是如何工作的：

        ![由QuickLaTeX.com渲染](pic/quicklatex.com-e1f188a9277bfcecb9edbef93064a21f_l3.svg)

        该算法将一个加权图G和一个起始节点S作为输入。该算法的主要目标是计算S和G中其他每个节点之间的最短距离。

        我们首先初始化两个数组dist和prev。dist将存储从S到G中每个节点的最短距离。另一方面，我们用prev来跟踪从S到每个节点路径上的前一个节点。从S到它自己的距离是0，而且没有S的前一个节点，这就是为什么`dist[S]`将被设置为0，`prev[S]`将被设置为null。

        在这个伪代码中，我们初始化一个包含G中所有节点的优先级队列Q，Q中一个节点的优先级是当前从S到该节点的最短距离。

        我们重复这些步骤，直到优先级队列为空。对于U的每个未访问的邻居V，我们通过将U到V的边的长度加上当前到U的最短距离，计算出S到V的暂定距离tempDist。

        如果tempDist小于当前到V的最短距离，我们将`dist[V]`更新为tempDist，并将`prev[V]`设置为U。

        在while循环结束后，我们返回数组dist和prev，其中包含从S到G中每个节点的最短距离以及从S到每个节点路径上的前一个节点。

    2. 时间和空间复杂度

        Dijkstra算法的时间复杂度是$O(V^2)$，其中V是图中节点的数量。然而，如果使用[邻接列表](https://www.baeldung.com/cs/graphs#2-adjacency-list)表示图，使用二进制堆，时间复杂度将降低到$O(E log V)$。

        另一方面，空间复杂度为O(V)。其原因是我们必须将列表中的所有顶点作为输出存储。正如我们所预料的那样，当图越来越大时，时间复杂度可能是巨大的。这就是为什么在今天的应用中要应用不同类型的优化。

3. A*算法

    A*（A-star）算法是Dijkstra算法的一个扩展。它有一个启发式的组件来指导向目标节点的搜索。它被广泛用于寻找路径的应用，如机器人、地图应用和视频游戏。A*通常比Dijkstra算法更受欢迎，因为当有一个很好的启发式算法来引导目标节点的搜索时，它可以更快。

    1. A*和Dijkstra算法的比较

        `A*`是一个面向特定目标的算法。这意味着它只寻找从特定源头到特定目标的最短路径。相比之下，Dijkstra算法找到了从一个指定的源到所有可能的目标的最短路径树。由于A*算法使用启发式方法来引导搜索目标，因此当目标已知且启发式方法有效时，它比Dijkstra算法更有效率。然而，启发式的使用意味着该算法可能不会探索所有的路径。如果启发式算法不被接受，这将影响最短路径的寻找。

        相比之下，Dijkstra算法保证找到从源头到所有可能目标的真正最短路径。另一方面，这将导致探索许多不必要的路径，正如前面提到的，对于大型图来说，效率可能很低。因此，在`A*`和Dijkstra算法之间的选择取决于具体问题和启发式方法。如果目标是已知的，并且有一个有效的启发式函数或图有负边，那么`A*`可能更有效率。但是，如果我们不知道目标，或者启发式方法不有效，Dijksta算法可能是更好的选择。

        [由QuickLaTeX.com渲染](pic/quicklatex.com-d73beff99ba4d861417d51fda84fc655_l3.svg)

4. 其他最短路径算法

    在某些情况下，Dijkstra或A*可能也不是最佳解决方案。其他一些常用的算法有：

    - [Floyd-Warshall算法](https://www.baeldung.com/cs/floyd-warshall-shortest-path)
    - [Johnson算法](https://www.baeldung.com/cs/all-pairs-shortest-paths-johnsons-algorithm)
    - [Bellman-Ford算法](https://www.baeldung.com/cs/bellman-ford)
    - [Prim算法](https://www.baeldung.com/cs/prim-algorithm)
    - [克鲁斯卡算法](https://www.baeldung.com/cs/kruskals-vs-prims-algorithm)
5. 总结

    在本教程中，我们分析了两种最短路径算法，Dijkstra和A*。我们研究了Dijkstra算法是如何工作的，以及当我们有更复杂的算法，如A*。我们还比较了A*和Dijkstra的算法，以及在何种情况下哪种算法会更有效。应该记住，这些算法为这么多的发现铺平了道路。

## 相关文章

- [ ] [Algorithms for Computing Routes on a Map](https://www.baeldung.com/cs/routes-optimal-on-map)
