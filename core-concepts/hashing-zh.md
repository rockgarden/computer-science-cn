# 深入了解散列

<https://www.baeldung.com/cs/hashing>

1. 简介

    散列被广泛应用于算法、数据结构和密码学中。

    在本教程中，我们将详细讨论散列及其应用领域。

    首先，我们将讨论散列的核心概念和原理。

    其次，我们将分析加密散列函数。

    然后，我们将定义几种散列算法以及对它们的可能攻击。

    最后，我们将介绍常见的基于散列的数据结构。

2. 散列

    1. 散列函数

        散列函数接收长度可变的输入数据，并产生固定长度的输出值。我们通常将其称为散列码、摘要、散列值或简称散列。散列函数有几个重要的特性：

        - 散列是一个单向过程。因此，我们无法从散列值中获取原始数据。
        - 散列函数是确定性的。因此，当我们向散列函数传递相同的输入时，它总会生成相同的输出散列码，例如，SHA-1 散列码的长度为 160 比特。
        - 均匀性 - 哈希值应均匀分布在可能的值中。
        - 特定的哈希函数总是产生固定大小的输出。
        - 它应该足够复杂，以最大限度地降低碰撞风险。

        举例来说，我们来分析一下 Java 的 String 类中使用的哈希函数：

        ```java
        public int hashCode() {
            int h = hash;
            if (h == 0 && value.length > 0) {
                char val[] = value;
                for (int i = 0; i < value.length; i++) {
                    h = 31 * h + val[i];
                }
                hash = h;
            }
            return h;
        }
        ```

        Joshua Bloch 在《[Effective Java](https://www.oracle.com/java/technologies/effectivejava.html)》一书中解释说，之所以有意选择数值 31，是因为它是一个奇素数。使用偶数会造成信息丢失，因为乘以 2 类似于移位。简单地说，使用有多个除数的数值会导致更多碰撞。因此，使用除数较少的数字更安全。

        让我们来看看 [hashcode()](https://www.baeldung.com/java-hashcode) 方法的实际应用：

        ```java
        public static void main(String[] args) {
            String anotherTest = "java";
            String test = "test";
            String oneMoreTest = "dev";
            System.out.println(test.hashCode()); // output: 3556498
            System.out.println(test.hashCode()); // output: 3556498
            System.out.println(anotherTest.hashCode()); // output: 3254818
            System.out.println(oneMoreTest.hashCode()); // output: 99349
        }
        ```

        通过分析结果，我们可以看到上述哈希函数的一些特性。

        首先，调用 hashcode() 是一个单向过程。我们无法从生成的哈希值（int）中获取原始字符串。

        其次，该方法具有确定性。我们在一个测试变量上调用两次，得到的哈希值是一样的。

        最后，它总是生成固定长度的哈希码，因为 Java 的 int 类型是固定大小的，这一点我们可以在 Java 虚拟机文档中找到。

    2. 加密哈希函数

        加密散列函数是一组专门的散列函数。它们提供更高水平的安全性。因此，它们被用于密码验证、数据完整性验证、区块链（加密货币）等加密目的。

        除了标准哈希函数的特性外，它们还可以根据用途满足以下标准：

        - 抗碰撞性(Collision resistance)： 加密哈希函数必须完全抗碰撞。我们已经知道，标准哈希函数应将碰撞风险降至最低。但是，最小化并不意味着不会发生碰撞。之前，我们分析了一个 hashcode() 函数。因为它返回的是一个 int 值，所以哈希值的变化受限于 int 范围 -2147483648 到 2147483647。因此，当我们用完所有可能的值时，就会发生碰撞（在某些情况下，碰撞甚至会在此之前发生）。因此，在加密哈希函数中不可能发生任何碰撞。
        - 前像抗性(Preimage resistance)： 对于任何具有摘要 h 的加密散列函数 H，都不应该有任何快速方法找到 $H(m) = h$ 的信息。
        - 第二种抗前像能力(Second preimage resistance)： 如果某个函数具有collision-resistant，那么它总是具有第二抗预映像性，但它不可能具有抗预映像性。就加密而言，缺乏抗前像能力的散列函数是不安全的。
        - "与随机通告无关性(Indifferentiability from random oracles)"： 不可能找到两个哈希值略有不同的信息（输入值）。
        - 计算任何信息的哈希值都应该是快速的。
        - 如果信息发生了变化，哪怕是微小的变化，新的哈希值也应与旧的哈希值有明显不同。换句话说，我们不应该在新旧哈希代码之间找到任何相关性。
        - 伪随机性。

        简而言之，加密哈希函数应安全、有效、可靠。

    3. 散列算法

        让我们来介绍几种常用的散列算法。

        消息加密算法 5（Message-Digest algorithm 5）由罗恩-里夫斯于 1991 年提出。对于任何长度的输入，MD5 都能生成 128 位长度的摘要。遗憾的是，MD5 的碰撞可在几秒钟内发现。因此，它不应再用于加密目的。它通常用作数据完整性验证的校验和。

        安全散列算法 2（SHA-2）由几个散列函数组成，即 SHA-224、SHA-256、SHA-384 和 SHA-512。美国国家安全局（NSA）设计了 SHA-2，随后美国国家标准与技术研究院（NIST）于 2001 年将其作为联邦信息处理标准（FIPS）发布。一些现代安全应用程序和协议使用 SHA-2，包括 TLS、SSL、SSH 和比特币。

        [BLAKE3](https://github.com/BLAKE3-team/BLAKE3) 是我们列表中最新的算法，于 2020 年 1 月 9 日发布。该算法生成 256 位长摘要，可任意扩展。

        BLAKE3 是一种单一算法，内部使用马克尔树构建。它还具有通用性、快速性和并行性。这些特性使它成为检查文件完整性、加密签名输入和信息验证的理想选择。不过，GitHub 上的官方文档指出，不建议将其用于密码散列。

3. 加密攻击

    在本节中，我们将看到一些可能影响散列函数的加密攻击。

    1. 暴力攻击

        我们已经知道，散列函数是单向的，因此无法从其摘要中检索到原始信息。散列函数也是统一的，因此给定的算法总能为特定信息（如密码）生成相同的散列值。另一方面，统一性使得猜测给定哈希值的信息成为可能。

        蛮力攻击(Brute Force)可以利用这一特性，即检查所有可能的信息，找出符合给定哈希值的信息。从理论上讲，所有哈希函数都容易受到这种攻击。实际上，暴力攻击的计算复杂度非常高。因此，使用足够长的哈希值几乎不可能找到符合特定哈希值的信息。

    2. 生日攻击

        另一种方法是生日攻击，它依赖于一个名为 "生日悖论(paradox)" 的统计问题。让我们来简单描述一下。第一个问题是：我们应该在一个房间里聚集多少人，才能获得至少 50%的概率，找到一个在特定日期（如 1 月 1 日）出生的人？答案是 253。

        第二个问题，也是问题的核心：我们需要在一个房间里聚集多少人，才能获得至少 50%的概率，找到至少两个出生于特定日期（如 1 月 1 日）的人？答案令人吃惊：23。23 人组成了 253 对不同的人。

        因此，对于 128 比特长的哈希值，我们需要检查 2^128 条信息才能找到符合特定哈希值的信息。然而，只需要 2^64 次检查就能发现碰撞。
        为了说明这一点，假设我们有一台机器，在这台机器上找到符合特定哈希值的信息需要 600 000 年。而在同一台机器上，找到碰撞（具有相同哈希值的第二条信息）只需要一个小时！

        为什么碰撞如此危险？举例来说，有些算法通过比较输入的密码和数据库中存储的哈希值（即注册时）来验证用户身份。如果有一种简单快速的方法可以发现碰撞，那么碰撞后的短语就可以代替原来的短语作为密码使用。

    3. 拒绝服务

        拒绝服务(Denial of Service)是一种常用的加密攻击手段，用于使服务器超载。散列函数也可用于数据结构。

        简而言之，在发生碰撞之前，很多散列函数都能高效工作。添加大量碰撞数据（具有相同哈希值的输入）会稍微影响对此类数据结构进行操作的时间复杂性。因此，这会导致服务器无法执行所需的功能。

        这对负责防火墙或 SSH 等安全功能的服务器尤为危险。

4. 哈希表

    散列表是使用散列的最常见数据结构之一。它以键值对的形式存储数据，在我们需要快速访问数据时特别有用。

    访问散列表中存储的元素的时间复杂度是恒定的，因此它并不取决于表的大小或元素的位置。Java 的 HashMap 就是在特定编程语言中实现哈希表的一个很好的例子。

    本节我们将详细讨论散列表。

    1. 对条目进行散列

        如前所述，哈希表中的条目是键值对。在内部，哈希表将数据存储在一个桶数组中。在哈希表中，键值必须是唯一的。如果我们尝试用一个已存在的键来添加新值，会发生什么情况？这取决于实现方式，但在大多数情况下，值会被重写。

        让我们来解释一下在哈希表中添加条目的工作原理。给定一个条目后，哈希表中的哈希函数会根据密钥计算一个摘要。应用的散列算法是任意的。在前面的章节中，我们定义了有效的散列函数应具备的属性。生成的散列代码是一个索引，表示条目值在桶数组中的位置。

        我们可以通过相应的键来访问该值。在查找过程中，将计算所传键的哈希值，并找到相应值的位置（因为摘要就是值的索引）。如果传递的键没有用来存储任何值，那么结果将是什么都没有（在大多数编程语言中为空）。

        使用不可变数据类型作为键非常重要。举个例子，假设我们使用一个可变对象作为键。例如，我们使用的对象包含两个属性：名和姓。在向哈希表中添加值后，我们在哈希表之外更改了键的状态。例如，我们把名字从 Peter 改为 John。

        如果我们在改变键的状态后使用它来访问存储的值，会发生什么情况？具有新状态的键的摘要将与原始摘要不同。因此，我们可能什么也得不到，也可能得到一个不同的值，而这个值可能有不同的哈希值作为索引（因为我们在之前添加了它）。

    2. 碰撞

        我们已经知道，对于两个不同的信息，散列函数可以计算出相同的散列值，这就是碰撞。这种情况也可能发生在哈希表中。 在散列表中，有多种处理碰撞的方法。下面我们来介绍几种常见的方法。

        第一种叫做分离链(separate chaining)。在这种技术中，发生碰撞的元素被存储在同一数据桶中的独立数据结构中。通常，独立数据结构是一个列表。在这种情况下，哈希表操作的总时间复杂度是查找数据桶所需的时间（常量）+ 独立数据结构操作的时间。

        例如，访问链表中一个元素的时间复杂度为 O(n)。因此，在发生碰撞的情况下，访问元素的哈希表常量时间可以减少到 O(n)。因此，在数据桶中使用的数据结构效率越高越好。有时会使用不同种类的树来代替列表。

        第二种方法是开放寻址。在这种策略中，散列表会像普通散列表一样将碰撞元素存储在单独的桶中。不同之处在于计算摘要。当散列函数在计算散列过程中发现碰撞时，增量函数 p(i) 的结果值会被添加到散列函数结果中，其中 i 是一个探针数。

        在发生碰撞时的查找过程中，会对通过的密钥进行比较，直到找到正确的密钥。因此，最坏情况下的时间复杂度为 O(n)。根据所使用的增量函数，开放寻址有不同的变体：

        - 线性寻址，$p(i) = i$
        - 二次探测，适用于 $p(i) = i^2$
        - 双散列，$p(i) = i * h`(K)$，其中 $h`$ 是密钥 K 的附加增量函数。

5. 结论

    在本文中，我们深入探讨了散列问题。

    首先，我们介绍了散列函数和加密散列函数。其次，我们列举了几个例子。然后，我们介绍了几个加密攻击的例子。接着，我们介绍了哈希表数据结构。

    最后，我们分析了哈希表如何处理碰撞。
