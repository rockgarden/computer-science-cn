# [图形数据结构](https://www.baeldung.com/cs/graphs)

[数据结构](https://www.baeldung.com/cs/category/data-structures) [图形](https://www.baeldung.com/cs/category/graph-theory/graphs)

1. 概述

    图论中最重要的一点是如何在内存中存储图。

    在本教程中，我们将解释和比较图的三种主要数据结构，并展示它们的优缺点。

2. 定义问题

    在图论中，我们将节点称为顶点（V），将节点之间的连接称为边（E）。在处理图存储数据结构时，比较的依据是空间和时间的复杂性。

    1. 复杂性

        对于图存储数据结构，我们通常会关注以下复杂性：

        - 空间复杂性：在所选数据结构中存储一个图所需的大约内存量
        - 时间复杂性
          - 连接检查复杂性：查找两个不同节点是否为邻居所需的大致时间
          - 查找邻居复杂度：查找某个目标节点的所有邻居节点所需的大致时间
        如果存在连接第一个节点和第二个节点的边，我们就称这两个不同的节点为 "相邻节点"。

    2. 图的类型

        需要了解的一点是，图的定义通常基于两个因素。

        第一个因素是图是否加权。在图论中，我们有时只关心两个节点是否相连。有时，我们还关心从节点 u 移动到节点 v 的成本。

        在本文中，我们将展示每种数据结构在这两种情况下需要进行的更新。

        第二个因素是图是否有向。如果有一条从 u 到 v 的边，而且我们只能从节点 u 移动到节点 v，那么这个图就叫做有向图。然而，在无向图中，节点 u 和 v 之间的边意味着我们可以从节点 u 移动到节点 v，反之亦然。

        我们总是可以通过将 u 和 v 之间的每条边分离为两条边，将任何无向图转换为有向图。因此，在本文中，我们将讨论有向图，因为有向图是一种更普遍的情况。

3. 图数据结构

    在内存中存储图主要使用三种数据结构。

    1. 邻接矩阵

        第一个数据结构称为邻接矩阵。顾名思义，当我们需要快速查找两个节点是否相邻（连接）时，邻接矩阵很有帮助。邻接矩阵是一个大小为 $V^2$ 的二维布尔数组。

        我们把它命名为 G，那么我们应该有

        $G_{uv} = true$（如果有一条从 u 到 v 的直接边）。

        否则 $G_{uv} = false$。

        但是，如果处理过的图是加权的，那么每个单元格 $G_{uv}$ 都将是一个二维数组，其中包含 u 和 v 之间直接边的权重。

        如果 u 和 v 之间没有边，那么 $G_{uv}$ 将包含一个特殊的值，表示 u 和 v 之间没有直接连接。通常，我们可以使用一个较大的值，表示在 u 和 v 之间直接移动的成本很高，或者不可能。

    2. 邻接表

        第二个数据结构是邻接表。在这个数据结构中，我们的目标不是存储所有不同的 u 和 v 对的值，而是只存储每个节点的邻接节点。

        为此，我们创建了一个大小为 V 的数组 G。链表中的每个对象都将存储与索引为 u 的节点相连的节点 v 的索引。因此，每个单元 u 将有一个大小为 $N_u$ 的链表，其中 $N_u$ 相当于与节点 u 相连的节点数。

        换句话说

        $G_{ui};i\in[1, N_u]$ 这样，$G_{ui}$ 等于节点 u 的第 i 个邻居。

        如果我们处理的是加权图，那么链表中的每个对象都将包含两个信息：邻接节点 v 以及 u 和 v 之间的边的代价。

    3. 边列表

        最后一个数据结构是边列表。从名称可以推断，我们将图中的所有边都存储在一个链表中。

        链接列表中的每个对象都包含节点 u 和节点 v 两项内容，表示存在一条连接节点 u 和节点 v 的边：

        $G_{ui};i\in[1, E]$，这样 $G_{ui}$ 就包含了图中第 i 条边的信息，其中 E 表示与节点 u 相连的边数。

        如果图是加权的，那么每个对象将包含第三条信息，即节点 u 和 v 之间的边的权重。

        这种数据结构尤其适用于节点数量多但边数量少的图。

4. 复杂性

    下表概括介绍了每种图存储数据结构的复杂性。接下来，我们将解释每种复杂性背后的原因：

    ![由 QuickLaTeX.com 渲染](pic/quicklatex.com-7cf0c5b1720c3c662dd9fee02e1c0bf2_l3.svg)

    1. 空间复杂性

        - 邻接矩阵(Adjacency Matrix)：在邻接矩阵中，我们存储了一个大小为 $V^2$ 的数组，这意味着空间复杂度为 $O(V^2)$，其中 V 是图中的顶点数。
        - 邻接表(Adjacency List)：首先，我们存储一个大小为 V 的数组，其中每个单元格存储一个图节点的信息。这意味着，首先，我们需要 $O(V)$ 的空间复杂度来存储一个空数组。接下来，我们要计算所有链表的大小总和。由于我们只在出现新边时创建一个额外的链接列表对象，这意味着链接列表的大小总和等于 $O(E)$，其中 E 是图中边的数量。因此，总的空间复杂度为 $O(V+E)$。
        - 边列表(Edges List)：在这个数据结构中，我们只有一个链接列表，用于存储图中所有节点之间所有可能的边。因此，内存复杂度为$O(E)$。
    2. 连接检查复杂度

        - 邻接矩阵：使用邻接矩阵时，检查两个节点 u 和 v 是否相连是非常高效的。我们只需查找单元格 $G_{uv}$ 的值。因此，时间复杂度等于 $O(1)$。
        - 邻接表：要查找两个节点 u 和 v 是否相连，我们必须遍历存储在 $G_u$ 中的链表。在最坏的情况下，u 和 v 之间不会有一条边，我们最终会进行 $N_u$ 次迭代。因此，总复杂度为 $O(N_u)$，其中 $N_u$ 是 u 的邻接数。
        - 边列表：在边列表的情况下，我们没有其他选择，只能遍历链接列表中的所有边，并检查是否能找到节点 u 和 v 之间所需的边。复杂度为 $O(E)$，其中 E 是图中边的数量。
    3. 查找邻居复杂度

        - 邻接矩阵：换句话说，我们需要检查所有单元格 $G_{ui}$，其中 $i\in[1, V]$。因此，时间复杂度为 $O(V)$。
        - 邻接列表：快速查找所有相邻节点是创建邻接表的目的。由于单元格 $G_u$ 中存储了一个包含所有与 u 相连的节点 v 的链表，因此我们只需遍历 $G_u$ 中存储的链表即可。这种迭代的时间复杂度为 $O(N_u)$，其中 $N_u$ 代表节点 u 的邻居数量。
        - 边列表：边列表可能不是快速找到所有相邻节点的最佳解决方案。我们需要遍历链接列表中的所有存储对象，并检查存储的节点是否为 u 和 v。因此，时间复杂度为 $O(E)$，其中 E 是图中的边数。
5. 优缺点

    当我们需要快速检查两个节点是否有直接边时，邻接矩阵很有帮助。然而，其主要缺点是内存复杂度大。在图不包含大量节点的情况下，邻接矩阵最有帮助。此外，当图几乎是完整的（每个节点几乎都与所有其他节点相连）时，使用邻接矩阵可能是一个很好的解决方案。

    另一方面，当我们需要连续访问某个节点 u 的所有邻居时，邻接表是一个不错的选择。当我们需要检查两个节点是否有直接边时，邻接表的局限性就显现出来了。

    不过，值得注意的是，我们可以使用更新版的邻接表。我们可以将所有相邻节点存储在一个更复杂的数据结构中，例如集合，而不是存储在一个链表中。这样我们就能高效地遍历相邻节点。此外，我们还能以对数时间复杂度检查两个节点是否相连。

    边列表是使用最少的数据结构。主要是当我们有大量的**节点无法存储在内存**中，而只有少量的边时，我们才会使用边列表。在这种情况下，我们别无选择，只能使用边列表。因此，边列表的唯一优点就是内存空间复杂度低。

6. 结论

    在本文中，我们介绍了在内存中存储图的三种主要数据结构。

    接下来，我们讨论了大多数图算法执行的主要操作的空间和时间复杂性。

    最后，我们讨论了每种数据结构在空间和时间复杂度方面的优缺点，以及何时使用每种数据结构。
