# [对数时间复杂度](https://www.baeldung.com/cs/logarithmic-time-complexity)

1. 一览表

    在本教程中，我们将深入研究对数时间复杂性在计算机科学中的使用。

    更准确地说，我们将讨论对数的含义，以及在计算算法的时间复杂度时如何使用对数。

2. 计算机科学中的对数

    1. 什么是对数？

        对数是指数的数学逆数。

        让我们来看看指数的例子：

        \[ 2^3=8 \]

        这可以被描述为2本身乘以3倍时得到的数字：

        \[ 2^3 => 2*2*2=8 \]

        现在让我们来看看它的逆运算，对数：

        \[ \log_2(8)=3 \]

        这可以想象，我们把数字8除以2的次数得到1：

        \[ \log_2(8) = 3 => (((8 / 2) / 2) / 2) \]

        就像我们可以有一个具有不同基数的指数函数（在我们的示例中是基数2）一样，我们也可以有具有其他基数的对数。例如，基数3可以想象，在达到1之前，我们可以将某个数字除以3多少次。

        然而，就本教程而言，我们将坚持使用基数2的对数，因为它们是最常见的。接下来，让我们深入研究这一说法。

    2. 为什么是Base-2？

        这让我们想到了一个问题：为什么是base-2？真的，只是它经常出现。

        例如，在设计算法时，它们经常出现：

        1. 当我们需要反复将一个数组对半分割时--例如，在某些排序（如[合并排序](https://www.baeldung.com/java-merge-sort)）或搜索算法（如二进制搜索）中会用到这种操作；在这种情况下，我们可以将大小为 n 的数组对半分割的次数为 log2(n)
        2. 因此，如果我们将某物归类为O（log n），我们通常意味着O（log2 n）。然而，使用Big-O符号，这种简化不会造成问题，因为所有对数在渐近上都是等价的。

3. 时间复杂度的回顾

    在分析算法的时间复杂性时，我们必须问的问题是，随着算法的增长，其操作次数与输入大小之间的关系是什么。

    通常，我们将使用Big-O符号来比较不同算法的时间复杂度。

4. O(log n) 时间复杂度

    1. 二进制搜索示例

        让我们来看看对数在计算算法时间复杂度时的使用。具体来说，我们将使用二进制搜索算法及其对数时间复杂度——O（log n）。

        [二进制搜索](https://www.baeldung.com/java-binary-search)是一种用于搜索有序集合中元素的算法。

        它的工作原理是最初检查集合中心存在的值。如果它正在寻找的元素的值低于找到的元素，它会在集合的左半部分重复这个过程。如果它更大，就检查右半部分。这个过程会重复，直到找到元素。

        让我们看看它在行动中。我们从以下排序数组开始，搜索“2”：

        \[ \begin{array}{cccccccccc} 2 & 3 & 11 & 13 & 19 & 21 & 34 & 55 & 89 & 111 & 123 & 200\\ \end{array} \]

        我们从选择数组的中间开始（如果大小是偶数的，我们可以四舍五入）：

        \[ \begin{array}{cccccccccc} 2 & 3 & 11 & 13 & 19 & 21 & 34 & 55 & 89 & 111 & 123 & 200\\ & & & & & & \uparrow & & & \\ \end{array} \]

        我们正在搜索的数字低于导出的值，即21。因此，我们为数组的左半部分重复这个过程：

        \[ \begin{array}{cccc} 2 & 3 & 11 & 13 & 19\\ & & \uparrow & &\\ \end{array} \]

        同样，我们正在搜索的数字低于遇到的值。我们继续重复这个过程：

        \[ \begin{array}{cc} 2 & 3\\ \uparrow\\ \end{array} \]

        直到我们找到期望的值。

    2.  计算二进制搜索复杂性

        让我们思考一下随着输入的增长，操作次数和输入大小之间的关系。

        对于每次迭代，该算法将输入一分为二。因此，它的大小为12，然后是5（第二次迭代不计入已找到的值），然后是2。

        让我们向后工作，这样我们就可以直观地看到更大的数组会发生什么：

        1. 最后一次迭代，当输入大小为2时，需要1次操作才能找到结果；
        2. 第二次迭代，当输入大小为5时，需要2次操作；
        3. 第一次迭代，原始数组，当大小为12时，需要3次操作。

        从原理图上讲，它是这样的：

        \[ \begin{array}{ccc} 2 & \rightarrow & 1\\ 5 & \rightarrow & 2\\ 12 & \rightarrow & 3\\ \end{array} \]

        在每次迭代中，我们可以看到输入和操作数之间的关系是一个对数：

        \[ \begin{array}{ccccc} 2 & \rightarrow & 1 & \Rightarrow & log(2) = 1 \\ 5 & \rightarrow & 2 & \Rightarrow & log(5) = 2 \\ 12 & \rightarrow & 3 & \Rightarrow & log(12) = 3 \\ \end{array} \]

        总之，随着输入n的增长，时间复杂度为O(log n)。这是O(log n)的教科书案例。

        虽然还有其他以时间复杂度表示的对数，但O(log n)是迄今为止我们最看到的对数。

5. 结论

    在本教程中，我们讨论了对数，即它们是什么，以及我们在计算机科学中如何使用它们。为此，我们检查了二进制搜索及其时间复杂度：O(log n)。
